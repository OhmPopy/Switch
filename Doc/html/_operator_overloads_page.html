<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Portable C++ Framework - Reference Guide: Operator Overloads</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Portable C++ Framework - Reference Guide
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Pcf libraries contains all fundamental classes to access Hardware, Os, System, and more.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_operator_overloads_page.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Operator Overloads </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The principle of encapsulation is one of the most important notions in object-oriented design. This principle states that data stored inside an object should be accessible only to that object.</p>
<p>Operator overloads allow framework types to appear as if they were built-in language primitives.</p>
<p>Although allowed and useful in some situations, operator overloads should be used cautiously. There are many cases in which operator overloading has been abused, such as when framework designers started to use operators for operations that should be simple methods. The following guidelines should help you decide when and how to use operator overloading.</p>
<p>X AVOID defining operator overloads, except in types that should feel like primitive (built-in) types.</p>
<p><b>√ CONSIDER</b> defining operator overloads in a type that should feel like a primitive type.</p>
<p>For example, <a class="el" href="class_pcf_1_1_system_1_1_string.html" title="Represents text as a series of Unicode characters. ">Pcf::System::String</a> has operator== and operator!= defined.</p>
<p><b>√ DO</b> define operator overloads in structs that represent numbers (such as <a class="el" href="struct_pcf_1_1_system_1_1_double.html" title="Represents a double-precision floating-point number. ">Pcf::System::Double</a>).</p>
<p><b>X DO NOT</b> be cute when defining operator overloads.</p>
<p>Operator overloading is useful in cases in which it is immediately obvious what the result of the operation will be. For example, it makes sense to be able to subtract one DateTime from another DateTime and get a TimeSpan. However, it is not appropriate to use the logical union operator to union two database queries, or to use the shift operator to write to a stream.</p>
<p><b>X DO NOT</b> provide operator overloads unless at least one of the operands is of the type defining the overload.</p>
<p><b>√ DO</b> overload operators in a symmetric fashion.</p>
<p>For example, if you overload the operator==, you should also overload the operator!=. Similarly, if you overload the operator&lt;, you should also overload the operator&gt;, and so on.</p>
<p><b>√ CONSIDER</b> providing methods with friendly names that correspond to each overloaded operator.</p>
<h1><a class="anchor" id="EqualsSection"></a>
Equals</h1>
<p>The <a class="el" href="class_pcf_1_1_system_1_1_object.html" title="Supports all classes in the Pcf class hierarchy and provides low-level services to derived classes...">Pcf::System::Object</a> class implement the == and != operators and used the virtual bool Equals(const object&amp;) const; method. By default this method check if the objects are the same addresses. You must just overload this method for used your own implementation.</p>
<p>The Point class show how to used Equals method : </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Point : <span class="keyword">public</span> <a class="code" href="namespace_pcf_ac8ddf0130be632a27031ed7b7bc6bcaa.html#ac8ddf0130be632a27031ed7b7bc6bcaa">object</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> Equals(<span class="keyword">const</span> Point&amp; value)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> &amp;value != null and this-&gt;x == value.x and this-&gt;y == value.y;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> Equals(<span class="keyword">const</span> <span class="keywordtype">object</span>&amp; obj)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> &amp;obj != null and Is&lt;Point&gt;(obj) and this-&gt;Equals(To&lt;Point&gt;(obj));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  ...</div>
<div class="line"></div>
<div class="line">private:</div>
<div class="line">  <a class="code" href="namespace_pcf_a6f9d4a28d3e2967402626d3ca4ef5e23.html#a6f9d4a28d3e2967402626d3ca4ef5e23">int32</a> x;</div>
<div class="line">  <a class="code" href="namespace_pcf_a6f9d4a28d3e2967402626d3ca4ef5e23.html#a6f9d4a28d3e2967402626d3ca4ef5e23">int32</a> y;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">static <span class="keywordtype">string</span> Form1::CheckPoints(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2) {</div>
<div class="line">  <span class="keywordflow">if</span> (p1 == p2)</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Equals&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;Not equals&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="CompareToSection"></a>
CompareTo</h1>
<p>The <a class="el" href="class_pcf_1_1_system_1_1_i_comparable.html" title="Defines a generalized comparison method that a value type or class implements to create a type-specif...">Pcf::System::IComparable</a> interface implement the &lt;, &lt;=, &gt; and &gt;= operators. and used the virtual int32 CompareTo(const IComparable&amp;) const; method. You must just overload this method for used your own implementation.</p>
<p>The TimeSpan class show how to used CompareTo method: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TimeSpan : <span class="keyword">public</span> <a class="code" href="namespace_pcf_ac8ddf0130be632a27031ed7b7bc6bcaa.html#ac8ddf0130be632a27031ed7b7bc6bcaa">object</a>, <span class="keyword">public</span> IComparable {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  ...</div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespace_pcf_a6f9d4a28d3e2967402626d3ca4ef5e23.html#a6f9d4a28d3e2967402626d3ca4ef5e23">int32</a> CompareTo(<span class="keyword">const</span> TimeSpan&amp; value)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span> (&amp;value == null) <span class="keywordflow">return</span> 1;</div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;value &lt; value.value) <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;value &gt; value.value) <span class="keywordflow">return</span> 1;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespace_pcf_a6f9d4a28d3e2967402626d3ca4ef5e23.html#a6f9d4a28d3e2967402626d3ca4ef5e23">int32</a> CompareTo(<span class="keyword">const</span> IComparable&amp; obj)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span> (&amp;obj == null or not Is&lt;TimeSpan&gt;(obj))</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;CompareTo(To&lt;TimeSpan&gt;(obj));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  ...</div>
<div class="line"></div>
<div class="line">private:</div>
<div class="line">  <a class="code" href="namespace_pcf_a344227ee09c1b4f85a3a9271bd5c4199.html#a344227ee09c1b4f85a3a9271bd5c4199">int64</a> value;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">TimeSpan Test::GetMaxDuration(<span class="keyword">const</span> IEnumerable&lt;TimeSpan&gt;&amp; durations)<span class="keyword"> const </span>{</div>
<div class="line">  TimeSpan result;</div>
<div class="line">  <span class="keywordflow">foreach</span>(TimeSpan, duration, durations {</div>
<div class="line">    <span class="keywordflow">if</span> (duration &gt; result)</div>
<div class="line">      result = duration;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="OperatorInCPlusplusSection"></a>
Operator in C++</h1>
<p>This is a list of operators in the C++ programming languages. All the operators listed exist in C++.</p>
<p>When not overloaded, for the operators &amp;&amp;, ||, and , (the comma operator), there is a sequence point after the evaluation of the first operand.</p>
<p>C++ also contains the type conversion operators const_cast, static_cast, dynamic_cast, and reinterpret_cast. The formatting of these operators means that their precedence level is unimportant.</p>
<p>For the purposes of this tables, a, b, and c represent valid values (literals, values from variables, or return value), object names, or lvalues, as appropriate. R, S and T stand for any type(s), and K for a class type or enumerated type.</p>
<p>"Can overload" means that the operator can be overloaded in C++.</p>
<h1><a class="anchor" id="ArithmeticOperatorsSection"></a>
Arithmetic operators</h1>
<table class="doxtable">
<tr>
<th>Operator name </th><th>Syntax </th><th>Can overload </th><th>Protype examples As member of K </th><th>Protype examples Outside class definitions  </th></tr>
<tr>
<td>Basic assignment </td><td>a = b </td><td>Yes </td><td>R&amp; K::operator =(S b); </td><td>N/A </td></tr>
<tr>
<td>Addition </td><td>a + b </td><td> Yes </td><td>R K::operator +(S b); </td><td>R operator +(K a, S b); </td></tr>
<tr>
<td>Subtraction </td><td>a - b </td><td>Yes </td><td>R K::operator -(S b); </td><td>R operator -(K a, S b); </td></tr>
<tr>
<td>Unary plus (integer promotion) </td><td>+a </td><td>Yes </td><td>R K::operator +(); </td><td>R operator +(K a); </td></tr>
<tr>
<td>Unary minus (integer promotion) </td><td>-a </td><td>Yes </td><td>R K::operator -(); </td><td>R operator -(K a); </td></tr>
<tr>
<td>Multiplication </td><td>a/// b </td><td> Yes </td><td>R K::operator///(S b); </td><td>R operator///(K a, S b); </td></tr>
<tr>
<td>Division </td><td>a / b </td><td> Yes </td><td>R K::operator /(S b); </td><td>R operator /(K a, S b); </td></tr>
<tr>
<td>Modulo (integer remainder) </td><td>a % b </td><td> Yes </td><td>R K::operator %(S b); </td><td>R operator %(K a, S b); </td></tr>
<tr>
<td>Increment Prefix </td><td>++a </td><td>Yes </td><td>R&amp; K::operator ++(); </td><td>R&amp; operator ++(K a); </td></tr>
<tr>
<td>Increment Postfix </td><td>a++ </td><td>Yes </td><td>R K::operator ++(int); </td><td>R operator ++(K a, int); </td></tr>
<tr>
<td>Decrement Prefix </td><td>&minus;&minus;a </td><td>Yes </td><td>R&amp; K::operator &amp;minus;&amp;minus;(); </td><td>R&amp; operator &minus;&minus;(K a); </td></tr>
<tr>
<td>Decrement Postfix </td><td>a&minus;&minus; </td><td>Yes </td><td>R K::operator &amp;minus;&amp;minus;(int); </td><td>R operator &minus;&minus;(K a, int); </td></tr>
</table>
<h1><a class="anchor" id="ComparisonOperatorsSection"></a>
Comparison operators / reloational operators</h1>
<table class="doxtable">
<tr>
<th>Operator name </th><th>Syntax </th><th>Can overload </th><th>Protype examples As member of K </th><th>Protype examples Outside class definitions  </th></tr>
<tr>
<td>Equal to </td><td>a == b </td><td>Yes </td><td>bool K::operator ==(S const&amp; b); </td><td>bool operator ==(K const&amp; a, S const&amp; b); </td></tr>
<tr>
<td>Not Equal to </td><td>a != b -or- a <b>not_eq</b> b </td><td>Yes </td><td>bool K::operator !=(S const&amp; b); </td><td>bool operator !=(K const&amp; a, S const&amp; b); </td></tr>
<tr>
<td>Greater than </td><td>a &gt; b </td><td>Yes </td><td>bool K::operator &gt;(S const&amp; b); </td><td>bool operator &gt;(K const&amp; a, S const&amp; b); </td></tr>
<tr>
<td>Less than </td><td>a &lt; b </td><td>Yes </td><td>bool K::operator &lt;(S const&amp; b); </td><td>bool operator &lt;(K const&amp; a, S const&amp; b); </td></tr>
<tr>
<td>Greater than or equal to </td><td>a &gt;= b </td><td>Yes </td><td>bool K::operator &gt;=(S const&amp; b); </td><td>bool operator &gt;=(K const&amp; a, S const&amp; b); </td></tr>
<tr>
<td>Less than or equal to </td><td>a &lt;= b </td><td>Yes </td><td>bool K::operator &lt;=(S const&amp; b); </td><td>bool operator &lt;=(K const&amp; a, S const&amp; b); </td></tr>
</table>
<h1><a class="anchor" id="LogicalOperatorsSection"></a>
Logical operators</h1>
<table class="doxtable">
<tr>
<th>Operator name </th><th>Syntax </th><th>Can overload </th><th>Protype examples As member of K </th><th>Protype examples Outside class definitions  </th></tr>
<tr>
<td>Logical negation (NOT) </td><td>!a <em>-or-</em> <b>not</b> a </td><td>Yes </td><td>R K::operator !(); </td><td>R operator !(K a); </td></tr>
<tr>
<td>Logical AND </td><td>a &amp;&amp; b <em>-or-</em> a <b>and</b> b </td><td> Yes </td><td>R K::operator &amp;&amp;(S b); </td><td>R operator &amp;&amp;(K a, S b); </td></tr>
<tr>
<td>Logical OR </td><td>a || b <em>-or-</em> a <b>or</b> b </td><td> Yes </td><td>R K::operator \|\|(S b); </td><td>R operator ||(K a, S b); </td></tr>
</table>
<h1><a class="anchor" id="BitwiseOperatorsSection"></a>
Bitwise operators</h1>
<table class="doxtable">
<tr>
<th>Operator name </th><th>Syntax </th><th>Can overload </th><th>Protype examples As member of K </th><th>Protype examples Outside class definitions  </th></tr>
<tr>
<td>Bitwise NOT </td><td>~a <em>-or-</em> <b>compl</b> a </td><td>Yes </td><td>R K::operator ~(); </td><td>R operator ~(K a); </td></tr>
<tr>
<td>Bitwise AND </td><td>a &amp; b <em>-or-</em> a <b>bitand</b> b </td><td> Yes </td><td>R K::operator &amp;(S b); </td><td>R operator &amp;(K a, S b); </td></tr>
<tr>
<td>Bitwise OR </td><td>a | b <em>-or-</em> a <b>bitor</b> b </td><td> Yes </td><td>R K::operator \|(S b); </td><td>R operator |(K a, S b); </td></tr>
<tr>
<td>Bitwise XOR </td><td>a ^ b <em>-or-</em> a <b>xor</b> b </td><td> Yes </td><td>R K::operator ^(S b); </td><td>R operator ^(K a, S b); </td></tr>
<tr>
<td>Bitwise left shift </td><td>a &lt;&lt; b </td><td> Yes </td><td>R K::operator &lt;&lt;(S b); </td><td>R operator &lt;&lt;(K a, S b); </td></tr>
<tr>
<td>Bitwise right shift </td><td>a &gt;&gt; b </td><td> Yes </td><td>R K::operator &gt;&gt;(S b); </td><td>R operator &gt;&gt;(K a, S b); </td></tr>
</table>
<h1><a class="anchor" id="CompoundAssignmentOperatorsSection"></a>
Compound assignment operators</h1>
<table class="doxtable">
<tr>
<th>Operator name </th><th>Syntax </th><th>Meaning </th><th>Can overload </th><th>Protype examples As member of K </th><th>Protype examples Outside class definitions  </th></tr>
<tr>
<td>Addition assignment </td><td>a += b </td><td>a = a + b; </td><td>Yes </td><td>R&amp; K::operator +=(S b); </td><td>R&amp; operator +=(K a, S b); </td></tr>
<tr>
<td>Subtraction assignment </td><td>a -= b </td><td>a = a - b; </td><td>Yes </td><td>R&amp; K::operator -=(S b); </td><td>R&amp; operator -=(K a, S b); </td></tr>
<tr>
<td>Multiolication assignment </td><td>a *= b </td><td>a = a * b; </td><td>Yes </td><td>R&amp; K::operator *=(S b); </td><td>R&amp; operator *=(K a, S b); </td></tr>
<tr>
<td>Division, assignment </td><td>a /= b </td><td>a = a / b; </td><td>Yes </td><td>R&amp; K::operator /=(S b); </td><td>R&amp; operator /=(K a, S b); </td></tr>
<tr>
<td>Modulo assignment </td><td>a %= b </td><td>a = a % b; </td><td>Yes </td><td>R&amp; K::operator %=(S b); </td><td>R&amp; operator %=(K a, S b); </td></tr>
<tr>
<td>Bitwise AND assignment </td><td>a &amp;= b <em>-or-</em> a <b>and_eq</b> b </td><td>a = a &amp; b; </td><td>Yes </td><td>R&amp; K::operator &amp;=(S b); </td><td>R&amp; operator &amp;=(K a, S b); </td></tr>
<tr>
<td>Bitwise OR assignment </td><td>a |= b <em>-or-</em> a <b>or_eq</b> b </td><td>a = a | b; </td><td>Yes </td><td>R&amp; K::operator \|=(S b); </td><td>R&amp; operator |=(K a, S b); </td></tr>
<tr>
<td>Bitwise XOR assignment </td><td>a ^= b <em>-or-</em> a <b>xor_eq</b> b </td><td>a = a ^ b; </td><td>Yes </td><td>R&amp; K::operator ^=(S b); </td><td>R&amp; operator ^=(K a, S b); </td></tr>
<tr>
<td>Bitwise left shift assignment </td><td>a &lt;&lt;= b </td><td>a = a &lt;&lt; b; </td><td>Yes </td><td>R&amp; K::operator &lt;&lt;=(S b); </td><td>R&amp; operator &lt;&lt;=(K a, S b); </td></tr>
<tr>
<td>Bitwise right shift assignment </td><td>a &gt;&gt;= b </td><td>a = a &gt;&gt; b; </td><td>Yes </td><td>R&amp; K::operator &gt;&gt;=(S b); </td><td>R&amp; operator &gt;&gt;=(K a, S b); </td></tr>
</table>
<h1><a class="anchor" id="MemberAndPointerOperatorsSection"></a>
Member and pointer operators</h1>
<table class="doxtable">
<tr>
<th>Operator name </th><th>Syntax </th><th>Can overload </th><th>Protype examples As member of K </th><th>Protype examples Outside class definitions  </th></tr>
<tr>
<td>Array subsript </td><td>a[b] </td><td>Yes </td><td>R&amp; K::operator [](S b); </td><td>N/A </td></tr>
<tr>
<td>Indirection ("object pointed to by a") </td><td><em>a </em></td><td><em> Yes </em></td><td><em> R&amp; K::operator *(); </em></td><td><em> R&amp; operator *(K a); </em></td></tr>
<tr>
<td><em> Address ("address of a") </em></td><td><em> &amp;a </em></td><td><em> Yes </em></td><td><em> R K::operator &amp;(); </em></td><td><em> R operator &amp;(K a); </em></td></tr>
<tr>
<td><em> Structure dereference ("member b of object pointed to by a") </em></td><td><em> a-&gt;b </em></td><td><em> Yes </em></td><td><em> R</em> K::operator -&gt;(); </td><td>N/A </td></tr>
<tr>
<td>Structure reference ("member b of object a") </td><td>a.b </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>Member pointed to by b of object pointed to by a </td><td>a-&gt;*b </td><td>Yes </td><td>R&amp; K::operator -&gt;*(S b); </td><td>R&amp; operator -&gt;*(K a, S b); </td></tr>
<tr>
<td>Member pointed to by b of object a </td><td>a.*b </td><td>No </td><td>N/A </td><td>N/A </td></tr>
</table>
<h1><a class="anchor" id="OtherOperatorsSection"></a>
Other operators</h1>
<table class="doxtable">
<tr>
<th>Operator name </th><th>Syntax </th><th>Can overload </th><th>Protype examples As member of K </th><th>Protype examples Outside class definitions  </th></tr>
<tr>
<td>Function call </td><td>a(a1, a2) </td><td>Yes </td><td>R K::operator ()(S a, T b, ...); </td><td>N/A </td></tr>
<tr>
<td>Comma </td><td>a, b </td><td>Yes </td><td>R K::operator ,(S b); </td><td>R operator ,(K a, S b); </td></tr>
<tr>
<td>Ternary conditional </td><td>a ? b : c </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>Scope resolution </td><td>a::b </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>User-defined literals (since C++11) </td><td>"a"_b </td><td>Yes </td><td>N/A </td><td>R operator "" _b(T a); </td></tr>
<tr>
<td>Size-of </td><td>sizeof(a) <em>-or-</em> sizeof(type) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>Size of parameter pack (since C++11) </td><td>sizeof...(args) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>Align-of (since C++11) </td><td>alignof(type) <em>-or-</em> _Alignof(type) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>Type identification </td><td>typeid(a) <em>-or-</em> typeid(type) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>Conversion (C-style cast) </td><td>(type)a <em>-or-</em> type(a) </td><td>Yes </td><td>K::operator R(); </td><td>N/A </td></tr>
<tr>
<td>static_cast conversion </td><td>static_cast&lt;type&gt;(a) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>dynamic_cast conversion </td><td>dynamic_cast&lt;type&gt;(a) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>const_cast conversion </td><td>const_cast&lt;type&gt;(a) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>reinterpret_cast conversion </td><td>reinterpret_cast&lt;type&gt;(a) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>Allocate storage </td><td>new type </td><td>Yes </td><td>void* K::operator new(size_t x); </td><td>void* operator new(size_t x); </td></tr>
<tr>
<td>Allocate storage (array) </td><td>new type[n] </td><td>Yes </td><td>void* K::operator new[](size_t a); </td><td>void* operator new[](size_t x); </td></tr>
<tr>
<td>Deallocate storage </td><td>delete a </td><td>Yes </td><td>void K::operator delete(void* a); </td><td>void operator delete(void* a); </td></tr>
<tr>
<td>Deallocate storage (array) </td><td>delete[] a </td><td>Yes </td><td>void K::operator delete[](void* a); </td><td>void operator delete[](void* a); </td></tr>
<tr>
<td>Exception check (since C++11) </td><td>noexcept(a) </td><td>No </td><td>N/A </td><td>N/A </td></tr>
</table>
<h1><a class="anchor" id="SeeSection"></a>
See also</h1>
<p>Other Resources</p>
<ul>
<li><a class="el" href="_corelib_page.html#CorelibSection">Pcf.Core</a></li>
<li><a class="el" href="_framework_design_guidelines_page.html">Framework Design Guidelines</a></li>
<li><a class="el" href="_type_design_guidelines_page.html">Type Design Guidelines</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Dec 26 2016 22:48:26 for Portable C++ Framework - Reference Guide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
